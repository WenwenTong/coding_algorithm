#### 1.有效的括号：给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。 Refer to [leetcode 20](https://leetcode-cn.com/problems/valid-parentheses/)
有效字符串需满足：
* 左括号必须用相同类型的右括号闭合。
* 左括号必须以正确的顺序闭合。
注意空字符串可被认为是有效字符串。

> 利用栈的思想
```python
class Solution:
    def isValid(self, s: str) -> bool:
        dic = {'{': '}',  '[': ']', '(': ')'}
        stack=[]
        for c in s:
            if c in dic:
                stack.append(c)
            else:
                if stack and dic[stack[-1]]==c:
                    stack.pop()
                else:
                    return False
        return stack==[]
```
> 循环找成对括号删除法
```python
class Solution:
    def isValid(self, s: str) -> bool:
        while '{}' in s or '()' in s or '[]' in s:
            s=s.replace('{}','')
            s=s.replace('[]','')
            s=s.replace('()','')
        return s==''
```

#### 2.最长有效括号：给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。Refer to [leetcode 32](https://leetcode-cn.com/problems/longest-valid-parentheses/)
* 输入: "(()"
* 输出: 2
* 解释: 最长有效括号子串为 "()"
> 动态规划法: dp[i]表示以s[i]为结尾的最长有效括号长度。满足要求的s[i]必须等于')', 对于s[i-1]分两种情况讨论，注意是否越界。 时间复杂度O(n)
```python
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        if not s:return 0
        n=len(s)
        dp=[0]*n
        res=0
        for i in range(1,n):
            #满足要求的末尾肯定是')'
            if s[i]==')':
                if s[i-1]=='(':  #case1
                    dp[i]=dp[i-2]+2 if i>=2 else 2
                if s[i-1]==')':
                    if i-dp[i-1]-1>=0 and s[i-dp[i-1]-1]=='(':
                        dp[i]=dp[i-dp[i-1]-2]+dp[i-1]+2 if i-dp[i-1]>=2 else dp[i-1]+2
                res=max(dp[i],res)       
        return res
```
> 使用栈的方法：保存可以匹配的索引下标，然后将匹配索引排序，找最长连续子序列. O(nlogn)
```python
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        stack,res=[],[]
        for i in range(len(s)):
            if s[i]=='(':
                stack.append(i)
            if stack and s[i]==')':
                res.append(stack.pop())
                res.append(i)
        res.sort()  #找到匹配的索引
        maxlen=0
        i=0
        while i<len(res):  # 找最长连续子序列
            temp=i
            while temp+1<len(res) and res[temp]+1==res[temp+1]:
                temp=temp+1
            maxlen=max(maxlen,temp-i+1)
            i=i+1
        return maxlen
```
> 使用栈的方法，不用排序，栈中的元素表示上一不匹配位置的索引
```python
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        if not s:return 0
        res=0
        stack=[-1]
        for i in range(len(s)):
            if s[i]=='(':
                stack.append(i)
            else:
                stack.pop()
                if not stack:
                    stack.append(i)
                else:
                    res=max(res,i-stack[-1])
        return res
```
