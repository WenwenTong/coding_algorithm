#### 两数之和，三数之和，最接近的三数之和，四数之和I,II，使用hashmap，排序+双指针法
1. 两数之和
* 题目描述：给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。Refer to [leetcode 1](https://leetcode-cn.com/problems/two-sum/)
* 解法：哈希表法
```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        dic={}
        for i,num in enumerate(nums):
            if target-num in dic:
                j=dic[target-num]
                if j!=i:
                    return i,j
            else:
                dic[num]=i
```
2. 三数之和
* 题目描述：给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。答案中不可以包含重复的三元组。Refer to [leetcode 15](https://leetcode-cn.com/problems/3sum/)
* 解法：排序+双指针法。固定第一个元素，依次移动后面两个元素的指针。循环中间设置提前结束的条件和去除重复元素的条件
```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        #排序+双指针法
        if not nums or len(nums)<3:
            return []
        n=len(nums)
        nums.sort()
        res=[]
        for i in range(n-2):
            if nums[i]>0:
                return res
            if i>0 and nums[i]==nums[i-1]:   #去除重复的元素
                continue
            l=i+1
            r=n-1
            while l<r:
                add=nums[i]+nums[l]+nums[r]
                if add==0:
                    res.append([nums[i],nums[l],nums[r]])
                    while l<r and nums[l]==nums[l+1]: class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        #排序+双指针法
        if not nums or len(nums)<3:
            return []
        n=len(nums)
        nums.sort()
        res=[]
        for i in range(n-2):
            if nums[i]>0:
                return res
            if i>0 and nums[i]==nums[i-1]:   #去除重复的元素
                continue
            l=i+1
            r=n-1
            while l<r:
                add=nums[i]+nums[l]+nums[r]
                if add==0:
                    res.append([nums[i],nums[l],nums[r]])
                    while l<r and nums[l]==nums[l+1]:
                        l=l+1
                    while l<r and nums[r]==nums[r-1]:
                        r=r-1
                    l=l+1
                    r=r-1
                elif add>0:
                    r=r-1
                else:
                    l=l+1
        return res
                        l=l+1
                    while l<r and nums[r]==nums[r-1]:
                        r=r-1
                    l=l+1
                    r=r-1
                elif add>0:
                    r=r-1
                else:
                    l=l+1
        return res
```
3. 最接近的三数之和
* 题目描述：难度中等530收藏分享切换为英文关注反馈给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。Refer to [leetcode 16](https://leetcode-cn.com/problems/3sum-closest/)
```python
class Solution:
    def threeSumClosest(self, nums: List[int], target: int) -> int:
        if not nums or len(nums)<3:
            return 
        nums.sort()
        res=nums[0]+nums[1]+nums[2]
        for i in range(len(nums)-2):
            l=i+1
            r=len(nums)-1
            while l<r:
                tempsum=nums[i]+nums[l]+nums[r]
                if abs(tempsum-target)<abs(res-target):
                    res=tempsum
                if tempsum>target:
                    r=r-1
                elif tempsum<target:
                    l=l+1
                else:
                    return res
        return res
```
4. 四数之和
* 给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。Refer to [leetcode 18](https://leetcode-cn.com/problems/4sum/)
```python
class Solution:
    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:
        if not nums or len(nums)<4:
            return []
        n=len(nums)
        nums.sort()
        res=[]
        for p in range(n-3):
            if 4*nums[p]>target: #设置一些可以提前结束循环的条件
                break
            if p>0 and nums[p]==nums[p-1]:
                continue
            for i in range(p+1,n-2):
                if nums[p]+3*nums[i]>target:
                    break
                if i>p+1 and nums[i]==nums[i-1]:
                    continue
                l=i+1
                r=n-1
                while l<r:
                    add=nums[p]+nums[i]+nums[l]+nums[r]
                    if add==target:
                        res.append([nums[p],nums[i],nums[l],nums[r]])
                        while l+1<r and nums[l]==nums[l+1]:
                            l=l+1
                        while r-1>l and nums[r]==nums[r-1]:
                            r=r-1
                        l=l+1
                        r=r-1
                    elif add>target:
                        r=r-1
                    else:
                        l=l+1
        return res
```
