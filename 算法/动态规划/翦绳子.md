#### 题目描述：给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]k[1]...k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。若2 <= n <= 58。 Refer to [剑指offer 14](https://leetcode-cn.com/problems/jian-sheng-zi-lcof/)
#### 解法：动态规划，利用数学性质
1. 动态规划
```python
class Solution:
    def cuttingRope(self, n: int) -> int:
        if n==2:
            return 1
        if n==3:
            return 2
        if n==4:
            return 4
        dp=[0]*(n+1)
        dp[1]=1
        # dp[2]=2
        # dp[3]=3
        # for i in range(4,n+1):
        #     for j in range(1,i):
        #         dp[i]=max(dp[i],dp[j]*dp[i-j])
        for i in range(2,n+1):
            for j in range(1,i):
                dp[i]=max(dp[i],max(dp[j],j)*max(dp[i-j],i-j))
        return dp[n]
```
2. 利用数学性质：尽可能将绳子以长度 3 等分为多段时，乘积最大。3等分分不了，分为2等分
```python
class Solution:
    def cuttingRope(self, n: int) -> int:
        if n==2 or n==3:
            return n-1
        if n%3==0:
            return 3**(n//3)
        elif n%3==1:
            return 3**(n//3-1)*4
        else:
            return 3**(n//3)*2
```
```python
class Solution:
    def cuttingRope(self, n: int) -> int:
        if n==2 or n==3:
            return n-1
        res=1
        while n>4:
            res=res*3
            n=n-3
        return res*n
```
