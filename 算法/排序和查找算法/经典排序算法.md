### 排序：一般指将元素按大小进行排序
* 排序的稳定性：排序前2个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同
    * 稳定的排序：冒泡排序、插入排序、归并排序和基数排序
    * 不稳定的排序：选择排序、快速排序、希尔排序、堆排序
* 排序的时间复杂度(平均情况)：
    * O(n^2): 冒泡排序，选择排序，插入排序
    * O(nlogn): 归并排序，快速排序，堆排序, 希尔排序

#### 1. 冒泡排序(Bubble sort):比较相邻的两个元素，将值大的元素交换到右边
```python
   def bubblesort(lst): #冒泡排序
        for i in range(len(lst)-1): #需要进行n-1轮排序
            for j in range(0,len(lst)-1-i):
                if lst[j]>lst[j+1]:
                    lst[j],lst[j+1]=lst[j+1],lst[j]
        return lst
```

#### 2.选择排序：首先在未排序序列中找到大元素，存放到排序序列的末尾位置，然后，再从剩余未排序元素中继续寻找最大元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。
```python
   def select_sort(lst): #找最大，选择排序
        for i in range(len(lst)-1,0,-1):
            largest=i
            for j in range(i):
                if lst[j]>lst[largest]:
                    largest=j
            lst[largest],lst[i]=lst[i],lst[largest]
        return lst
```

#### 3. 插入排序：其是将未排序元素一个个插入到已排序列表中。对于未排序元素，在已排序序列中从后向前扫描，找到相应位置把它插进去
```python
   def insert_sort(lst): #插入排序
        for i in range(1,len(lst)): #待插入的元素
            current=lst[i]
            position=i
            while position>0 and lst[position-1]>current:
                lst[position]=lst[position-1]
                position=position-1
            lst[position]=current
        return lst
```

#### 4. 希尔排序：希尔排序是把序列按一定间隔分组，对每组使用直接插入排序；随着间隔减小，一直到1，使得整个序列有序。该复杂度为O(nlogn)，其实直接插入排序算法的改进版，也称为缩小增量排序。希尔排序是直接插入排序的一种改进，减少了其复制的次数，速度要快很多。
#### 4. 归并排序

#### 堆排序：利用最大堆或最小堆的性质
1. 首先将待排序的数组构造出一个大根堆：构造大根堆的过程是自底向上的
2. 取出这个大根堆的堆顶节点(最大值)，与堆的最下最右的元素进行交换，然后把剩下的元素再构造出一个大根堆
3. 重复第二步，直到这个大根堆的长度为1，此时完成排序。
```python
def maxheap_construct(arr,n,i):  #总共n个元素，构造第i的节点使得它为最大堆结构
    left=2*i+1 #左右子节点
    right=2*i+2
    largest=i
    #将子树根节点与左右节点的最大值交换
    if left<n and arr[i]<arr[left]:
        largest=left
    if right<n and arr[largest]<arr[right]:
        largest=right
    if largest!=i:
        arr[i],arr[largest]=arr[largest],arr[i]
        maxheap_construct(arr, n, largest)   #可能会破坏子数的最大堆结构
        
def maxheapsort(arr):
    n=len(arr)
    #构造最大堆
    #调整最大堆则是把每个子数调整为最大堆
    number=n//2
    for i in range(number,-1,-1):
        maxheap_construct(arr,n,i)
    print('max heap',arr)
    #构造好最大堆后,逐个获得最大值
    # 一个个交换元素
    for i in range(n-1, 0, -1): 
        arr[i], arr[0] = arr[0], arr[i]   # 交换
        maxheap_construct(arr, i, 0) 
arr=[50, 16, 30, 10, 60,  90,  2, 80, 70]
print('arr:',arr)
maxheapsort(arr)
print('maxheap sort',arr)
```
