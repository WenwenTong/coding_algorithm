### 排序：一般指将元素按大小进行排序
* 排序的稳定性：排序前2个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同
    * 稳定的排序：冒泡排序、插入排序、归并排序和基数排序
    * 不稳定的排序：选择排序、快速排序、希尔排序、堆排序
* 排序的时间复杂度(平均情况)：
    * O(n^2): 冒泡排序，选择排序，插入排序
    * O(nlogn): 归并排序，快速排序，堆排序
    * O(n^1.5): 希尔排序
    
#### 堆排序：利用最大堆或最小堆的性质
1. 首先将待排序的数组构造出一个大根堆：构造大根堆的过程是自底向上的
2. 取出这个大根堆的堆顶节点(最大值)，与堆的最下最右的元素进行交换，然后把剩下的元素再构造出一个大根堆
3. 重复第二步，直到这个大根堆的长度为1，此时完成排序。
```python
def maxheap_construct(arr,n,i):  #总共n个元素，构造第i的节点使得它为最大堆结构
    left=2*i+1 #左右子节点
    right=2*i+2
    largest=i
    #将子树根节点与左右节点的最大值交换
    if left<n and arr[i]<arr[left]:
        largest=left
    if right<n and arr[largest]<arr[right]:
        largest=right
    if largest!=i:
        arr[i],arr[largest]=arr[largest],arr[i]
        maxheap_construct(arr, n, largest)   #可能会破坏子数的最大堆结构
        
def maxheapsort(arr):
    n=len(arr)
    #构造最大堆
    #调整最大堆则是把每个子数调整为最大堆
    number=n//2
    for i in range(number,-1,-1):
        maxheap_construct(arr,n,i)
    print('max heap',arr)
    #构造好最大堆后,逐个获得最大值
    # 一个个交换元素
    for i in range(n-1, 0, -1): 
        arr[i], arr[0] = arr[0], arr[i]   # 交换
        maxheap_construct(arr, i, 0) 
arr=[50, 16, 30, 10, 60,  90,  2, 80, 70]
print('arr:',arr)
maxheapsort(arr)
print('maxheap sort',arr)
```
